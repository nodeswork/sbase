import * as _ from 'underscore'
import { validator2 } from '@nodeswork/utils'
import { Document, Model, Mongoose, Schema, SchemaOptions } from 'mongoose'

export interface MongooseOptions {
  initialized:     boolean
  config:          NWMongooseConfig
  schema?:         {}
  mongooseSchema?: Schema
}

export interface NWMongooseConfig extends SchemaOptions {
  discriminatorKey?: string
}

export interface NWMongooseType {

  new(): NWMongooseModel

  Config(config: NWMongooseConfig): NWMongooseType

  Schema(schema: object): NWMongooseType

  Plugin(): NWMongooseType

  Index(): NWMongooseType

  Virtual(): NWMongooseType

  Pre(): NWMongooseType

  Post(): NWMongooseType

  /**
   * Expose mongoose options generated by current NWMongooseModel.
   */
  $mongooseOptions(): MongooseOptions

  /**
   * Register current NWMongooseModel to specific mongoose instance.
   */
  $register<D extends NWMongooseModel, T extends INWMongooseModel<D>>(
    mongoose: Mongoose
  ): T
}

export interface INWMongooseModel<T extends NWMongooseModel> extends Model<T> {
}

export interface NWMongooseModel extends Document {
}

export class NWMongooseModel {

  // reflects the configuration for current model.
  static $CONFIG: NWMongooseConfig;

  // preset the schema of current model.
  static $SCHEMA: {};

  // preset the pre hooks of current model.
  static $PRES: object[];

  // placeholder for calculated mongoose options.
  static _mongooseOptions: MongooseOptions;

  static Config(config: NWMongooseConfig): NWMongooseType {
    if (!('$CONFIG' in Object.getOwnPropertyNames(this))) {
      this.$CONFIG = {};
    }
    _.extend(this.$CONFIG, config);
    return this;
  }

  static Schema(schema: object): NWMongooseType {
    this.$SCHEMA = schema;
    return this;
  }

  static Plugin(): NWMongooseType {
    return this;
  }

  static Index(): NWMongooseType {
    return this;
  }

  static Virtual(): NWMongooseType {
    return this;
  }

  static Pre(): NWMongooseType {
    return this;
  }

  static Post(): NWMongooseType {
    return this;
  }

  static $mongooseOptions(): MongooseOptions {
    this._$initialize();
    if (this._mongooseOptions.initialized) {
      return this._mongooseOptions;
    }

    const validateSchema = validator2.isRequired({
      message: '$SCHEMA is missing',
      meta: {
        schemaClass: this.name
      }
    });

    validateSchema(this.$SCHEMA);

    // TODO: expand fields from super class.
    this._mongooseOptions.schema = this.$SCHEMA;
    this._mongooseOptions.config = this.$CONFIG;

    var mongooseSchema = new Schema(
      this._mongooseOptions.schema, this._mongooseOptions.config
    );

    // mongooseSchema.pre

    this._mongooseOptions.mongooseSchema  = mongooseSchema;
    this._mongooseOptions.initialized     = true;
    return this._mongooseOptions;
  }

  static $register<D extends NWMongooseModel, T extends INWMongooseModel<D>>(
    mongoose: Mongoose
  ): T {
    let model: T = mongoose.model(
      this.name, this.$mongooseOptions().mongooseSchema
    ) as T;
    return model;
  }

  static _$initialize() {
    if ('_mongooseOptions' in Object.getOwnPropertyNames(this)) {
      this._mongooseOptions = {
        initialized:  false,
        config:       {},
      };
    }
  }
}

NWMongooseModel
  .Config({})
  .Schema({})
